<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>💣 Bomb Countdown • Scan Quest (Hybrid Audio)</title>
  <style>
    :root{
      --bg: #000;
      --fg: #e74c3c;
      --fg-quiet: #ffb3b3;
      --brand: #00ff88;
      --text: #f2f2f2;
    }
    body { background: var(--bg); color: var(--fg); font-family: 'Courier New', monospace; text-align:center; overflow:hidden; margin:0; }
    header { display:flex; align-items:center; gap:12px; padding:12px 16px; border-bottom:1px solid #111; }
    header img { height:40px; }
    header .brand { color: var(--brand); letter-spacing:1px; font-weight:bold; }
    main { padding: 12px 16px; }
    h1 { font-size: 2.6em; margin: 16px 0 6px; }
    #timer { font-size: 5em; margin: 6px 0 10px; }
    input, button { font-size: 1.05em; padding: 10px 14px; margin: 6px; border-radius: 8px; border: none; }
    input { background:#111; color:#fff; border:1px solid #222; }
    button { background: var(--fg); color: #fff; cursor: pointer; }
    #message { font-size: 1.2em; margin-top: 10px; min-height: 1.4em; color: var(--text); }
    #flash { position: fixed; inset: 0; background: var(--fg); opacity: 0; pointer-events: none; }
    #overlay {
      position: fixed; inset: 0; background: rgba(0,0,0,0.95);
      display:flex; flex-direction:column; align-items:center; justify-content:center; gap:14px; color:#fff;
      z-index: 10; padding: 24px;
    }
    #controls { display:flex; align-items:center; gap:10px; justify-content:center; margin-top:8px; flex-wrap: wrap; }
    #err { color:var(--fg-quiet); font-size:0.95em; min-height:1.2em; }
    .hint { color:#ccc; font-size:0.95em; max-width: 680px; }
    input[type="range"] { width: 200px; }
    footer { color:#777; font-size:12px; padding: 10px 0 16px; }
    #status { font-size: 0.95em; color:#bbb; min-height:1.2em; }
  </style>
</head>
<body>
  <div id="flash"></div>

  <header>
    <img src="logo.svg" alt="Logo">
    <div class="brand">Scan Quest</div>
  </header>

  <div id="overlay">
    <h2>🔊 Click to Arm the Device</h2>
    <p class="hint">If your browser blocks autoplay or MP3 decoding, we’ll auto‑fallback to a procedural soundtrack.</p>
    <div id="controls">
      <button id="startBtn">Arm & Begin</button>
      <button id="testBtn" title="Plays a short beep to confirm audio works">Test sound</button>
      <label>Volume <input id="vol" type="range" min="0" max="1" step="0.01" value="0.8"></label>
      <button id="muteBtn">Mute</button>
    </div>
    <div id="status"></div>
    <div id="err"></div>
  </div>

  <main>
    <h1>💣 Bomb Countdown 💣</h1>
    <div id="timer">03:00</div>
    <p style="color:var(--text)">Enter the deactivation code below to secure the area.</p>
    <input id="codeInput" type="text" placeholder="Enter code"/>
    <button id="deactivateBtn">Deactivate</button>
    <p id="message"></p>
  </main>

  <footer>© Scan Quest</footer>

  <script>
    // ===== Config =====
    let durationSeconds = 180;               
    const correctCode = "1540";              
    const nextUrl = "/success.html";         
    const musicURL = "https://cdn.pixabay.com/audio/2021/08/09/audio_c4f134fb2b.mp3"; // try first

    // ===== Elements =====
    const timerEl = document.getElementById('timer');
    const msgEl = document.getElementById('message');
    const flash = document.getElementById('flash');
    const overlay = document.getElementById('overlay');
    const startBtn = document.getElementById('startBtn');
    const testBtn = document.getElementById('testBtn');
    const vol = document.getElementById('vol');
    const muteBtn = document.getElementById('muteBtn');
    const errEl = document.getElementById('err');
    const statusEl = document.getElementById('status');

    // ===== WebAudio & hybrid engine =====
    let ctx, masterGain, musicBuffer, musicSource, isMuted = false;
    let bedNodes = []; // procedural bed nodes
    let tickInterval = null;

    function ensureCtx() {
      if (!ctx) {
        ctx = new (window.AudioContext || window.webkitAudioContext)();
        masterGain = ctx.createGain();
        masterGain.gain.value = parseFloat(vol.value);
        masterGain.connect(ctx.destination);
      }
      if (ctx.state === 'suspended') ctx.resume();
    }

    function setVolume(v) { if (masterGain) masterGain.gain.value = v; }
    function toggleMute() {
      isMuted = !isMuted;
      if (masterGain) masterGain.gain.value = isMuted ? 0 : parseFloat(vol.value);
      muteBtn.textContent = isMuted ? "Unmute" : "Mute";
    }

    function testBeep() {
      ensureCtx();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = 'sine'; o.frequency.value = 880;
      g.gain.value = 0.0001;
      g.gain.exponentialRampToValueAtTime(0.5, ctx.currentTime + 0.02);
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.35);
      o.connect(g).connect(masterGain);
      o.start(); o.stop(ctx.currentTime + 0.4);
    }

    // --- MP3 path (preferred) with Safari-safe decode ---
    async function tryLoadMusicBuffer() {
      ensureCtx();
      statusEl.textContent = "Loading MP3…";
      const res = await fetch(musicURL, { mode: 'cors', cache: 'force-cache' });
      const arr = await res.arrayBuffer();
      // Safari-safe callback form:
      return new Promise((resolve, reject) => {
        ctx.decodeAudioData(arr, resolve, reject);
      });
    }
    function startMusicLoop() {
      stopMusicLoop();
      musicSource = ctx.createBufferSource();
      musicSource.buffer = musicBuffer;
      musicSource.loop = true;
      musicSource.connect(masterGain);
      musicSource.start(0);
      statusEl.textContent = "MP3 soundtrack playing.";
    }
    function stopMusicLoop() {
      try { musicSource && musicSource.stop(); } catch(e) {}
      musicSource = null;
    }

    // --- Procedural fallback bed ---
    function startProceduralBed() {
      ensureCtx();
      stopProceduralBed();
      statusEl.textContent = "Fallback: procedural soundtrack.";

      // Low pulsing bass with tremolo
      const bass = ctx.createOscillator(); bass.type = 'sawtooth'; bass.frequency.value = 80;
      const bassGain = ctx.createGain(); bassGain.gain.value = 0.035;
      const lfo = ctx.createOscillator(); lfo.type='sine'; lfo.frequency.value = 1.2;
      const lfoGain = ctx.createGain(); lfoGain.gain.value = 0.03;
      lfo.connect(lfoGain).connect(bassGain.gain);
      bass.connect(bassGain).connect(masterGain);
      bass.start(); lfo.start();
      bedNodes.push(bass,bassGain,lfo,lfoGain);

      // Airy noise pad
      const buffer = ctx.createBuffer(1, ctx.sampleRate * 2, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0;i<data.length;i++) data[i] = Math.random()*2-1;
      const noise = ctx.createBufferSource(); noise.buffer = buffer; noise.loop = true;
      const band = ctx.createBiquadFilter(); band.type='bandpass'; band.frequency.value = 600; band.Q.value = 1.5;
      const noiseGain = ctx.createGain(); noiseGain.gain.value = 0.02;
      noise.connect(band).connect(noiseGain).connect(masterGain);
      noise.start();
      bedNodes.push(noise, band, noiseGain);

      // Tick every second
      tickInterval = setInterval(()=>{
        const click = ctx.createOscillator();
        const g = ctx.createGain();
        click.type = 'square'; click.frequency.value = 1200;
        g.gain.value = 0.0001;
        g.gain.exponentialRampToValueAtTime(0.5, ctx.currentTime + 0.001);
        g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + 0.08);
        click.connect(g).connect(masterGain);
        click.start(); click.stop(ctx.currentTime + 0.09);
      }, 1000);
    }
    function stopProceduralBed() {
      try { tickInterval && clearInterval(tickInterval); } catch(e){}
      tickInterval = null;
      bedNodes.forEach(n=>{ try{ n.stop && n.stop(); }catch(e){} try{ n.disconnect && n.disconnect(); }catch(e){} });
      bedNodes = [];
    }

    // Explosion FX
    function explosion() {
      ensureCtx();
      const duration = 1.2;
      const buffer = ctx.createBuffer(1, ctx.sampleRate * duration, ctx.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0;i<data.length;i++) {
        const t = i / ctx.sampleRate;
        const env = Math.exp(-3.5 * t);
        data[i] = (Math.random()*2-1) * env;
      }
      const src = ctx.createBufferSource(); src.buffer = buffer;
      const lp = ctx.createBiquadFilter(); lp.type='lowpass'; lp.frequency.value = 200;
      const g = ctx.createGain(); g.gain.setValueAtTime(0.9, ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + duration);
      src.connect(lp).connect(g).connect(masterGain);
      src.start();
    }

    // Visual flash
    function doFlash(duration = 300) {
      const el = document.getElementById('flash');
      el.style.transition = "none";
      el.style.opacity = "0.9";
      setTimeout(() => {
        el.style.transition = "opacity 0.5s ease-out";
        el.style.opacity = "0";
      }, duration);
    }

    // Countdown
    let countdownId = null;
    let timeLeft = durationSeconds;
    function renderTime() {
      const m = Math.floor(timeLeft / 60);
      const s = timeLeft % 60;
      timerEl.textContent = `${m}:${s.toString().padStart(2,'0')}`;
    }
    function startCountdown() {
      renderTime();
      countdownId = setInterval(() => {
        timeLeft--;
        renderTime();
        if (timeLeft < 0) {
          clearInterval(countdownId);
          timerEl.textContent = "💥 BOOM!";
          msgEl.textContent = "Too late! The bomb exploded!";
          stopMusicLoop();
          stopProceduralBed();
          doFlash();
          explosion();
        }
      }, 1000);
    }

    // Events
    vol.addEventListener('input', () => { if (!isMuted) setVolume(parseFloat(vol.value)); });
    muteBtn.addEventListener('click', toggleMute);
    testBtn.addEventListener('click', () => { errEl.textContent=""; try { ensureCtx(); testBeep(); } catch(e){ errEl.textContent="Test sound failed: "+e.message; } });

    startBtn.addEventListener('click', async () => {
      errEl.textContent = ""; statusEl.textContent = "";
      try {
        ensureCtx();
        // Try MP3 first
        try {
          musicBuffer = await tryLoadMusicBuffer();
          startMusicLoop();
        } catch (e) {
          console.warn("MP3 decode failed, falling back:", e);
          statusEl.textContent = "MP3 decode blocked; using procedural soundtrack.";
          startProceduralBed();
        }
        overlay.style.display = 'none';
        startCountdown();
      } catch (e) {
        errEl.textContent = "Could not start audio: " + e.message;
      }
    });

    // Deactivation
    function checkCode() {
      const entered = document.getElementById('codeInput').value.trim();
      if (entered === correctCode) {
        clearInterval(countdownId);
        timerEl.textContent = "✅ SAFE";
        msgEl.textContent = "You successfully deactivated the bomb!";
        stopMusicLoop();
        stopProceduralBed();
        doFlash();
        setTimeout(() => { window.location.href = nextUrl; }, 1200);
      } else {
        msgEl.textContent = "❌ Incorrect code! Try again!";
        doFlash(120);
      }
    }
    document.getElementById('deactivateBtn').addEventListener('click', checkCode);
    document.getElementById('codeInput').addEventListener('keyup', (e) => { if (e.key === 'Enter') checkCode(); });
  </script>
</body>
</html>
